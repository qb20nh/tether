// Runtime loader for compact infinite override payload.
// Payload file is generated by scripts/build_infinite_overrides.js.

const FORMAT_MAGIC = 0x49; // 'I'
const FORMAT_VERSION = 1;
const IS_NODE = typeof process !== 'undefined' && Boolean(process?.versions?.node);
const GZIP_MAGIC_0 = 0x1f;
const GZIP_MAGIC_1 = 0x8b;

const readCompressedOverrideBytes = async () => {
  const url = new URL('./infinite_overrides.bin.gz', import.meta.url);

  if (IS_NODE) {
    const { readFile } = await import('node:fs/promises');
    try {
      return new Uint8Array(await readFile(url));
    } catch (error) {
      if (error && typeof error === 'object' && error.code === 'ENOENT') {
        // Allow builder scripts to run before the binary payload is emitted.
        return null;
      }
      throw error;
    }
  }

  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to load infinite overrides payload: ${response.status} ${response.statusText}`);
  }
  return new Uint8Array(await response.arrayBuffer());
};

const gunzipBytes = async (compressedBytes) => {
  if (!compressedBytes) return null;

  if (typeof DecompressionStream === 'function') {
    const stream = new Response(compressedBytes).body.pipeThrough(new DecompressionStream('gzip'));
    return new Uint8Array(await new Response(stream).arrayBuffer());
  }

  if (IS_NODE) {
    const { gunzipSync } = await import('node:zlib');
    return new Uint8Array(gunzipSync(compressedBytes));
  }

  throw new Error('DecompressionStream is unavailable; cannot decode infinite overrides payload');
};

const readVarUint = (bytes, cursorRef) => {
  let value = 0;
  let shift = 0;

  while (cursorRef.index < bytes.length) {
    const byte = bytes[cursorRef.index++];
    value |= (byte & 0x7f) << shift;
    if ((byte & 0x80) === 0) return value >>> 0;
    shift += 7;
    if (shift > 28) {
      throw new Error('Invalid varint in infinite overrides payload');
    }
  }

  throw new Error('Truncated varint in infinite overrides payload');
};

const decodePackedOverrides = (bytes) => {
  if (!bytes || bytes.length === 0) return Object.freeze(Object.create(null));
  if (bytes.length < 3) {
    throw new Error('Invalid infinite overrides payload header');
  }
  if (bytes[0] !== FORMAT_MAGIC || bytes[1] !== FORMAT_VERSION) {
    throw new Error('Unsupported infinite overrides payload format');
  }

  const variantBits = bytes[2];
  if (!Number.isInteger(variantBits) || variantBits < 1 || variantBits > 8) {
    throw new Error(`Invalid infinite overrides variant-bit width: ${variantBits}`);
  }

  const variantMask = (1 << variantBits) - 1;
  const overrides = Object.create(null);
  let absoluteIndex = -1;
  const cursorRef = { index: 3 };

  while (cursorRef.index < bytes.length) {
    const token = readVarUint(bytes, cursorRef);
    const delta = token >>> variantBits;
    const variantId = token & variantMask;
    if (delta <= 0) {
      throw new Error('Invalid infinite overrides delta encoding');
    }
    absoluteIndex += delta;
    overrides[absoluteIndex] = variantId;
  }

  return Object.freeze(overrides);
};

const hasGzipHeader = (bytes) => (
  Boolean(bytes)
  && bytes.length >= 2
  && bytes[0] === GZIP_MAGIC_0
  && bytes[1] === GZIP_MAGIC_1
);

const decodeOverridePayloadBytes = async (bytes) => {
  const payloadBytes = hasGzipHeader(bytes) ? await gunzipBytes(bytes) : bytes;
  return decodePackedOverrides(payloadBytes);
};

const loadOverrideMap = async () => {
  const compressedBytes = await readCompressedOverrideBytes();
  return decodeOverridePayloadBytes(compressedBytes);
};

export const INFINITE_OVERRIDE_BY_INDEX = await loadOverrideMap().catch((err) => {
  console.error("Failed to load infinite overrides payload:", err);
  return Object.freeze(Object.create(null));
});

export const __TEST__ = {
  decodePackedOverrides,
  decodeOverridePayloadBytes,
  hasGzipHeader,
};
